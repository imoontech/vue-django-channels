{"version":3,"sources":["webpack:///webpack/universalModuleDefinition","webpack:///vue-django-channels.js","webpack:///webpack/bootstrap 85431114a5feeaa4d259","webpack:///./src/WebSocketBridge.js","webpack:///./src/index.js","webpack:///./~/reconnecting-websocket/dist/index.js"],"names":["root","factory","exports","module","define","amd","this","modules","__webpack_require__","moduleId","installedModules","i","l","call","m","c","value","d","name","getter","o","Object","defineProperty","configurable","enumerable","get","n","__esModule","object","property","prototype","hasOwnProperty","p","s","__webpack_exports__","_classCallCheck","instance","Constructor","TypeError","__WEBPACK_IMPORTED_MODULE_0_reconnecting_websocket__","__WEBPACK_IMPORTED_MODULE_0_reconnecting_websocket___default","WebSocketBridge","_extends","assign","target","arguments","length","source","key","_createClass","defineProperties","props","descriptor","writable","protoProps","staticProps","options","socket","streams","default_cb","url","protocols","_url","scheme","window","location","protocol","base_url","host","undefined","a","cb","_this","onmessage","event","msg","JSON","parse","data","action","stream","payload","Array","isArray","forEach","callback","push","filter","send","stringify","_this2","__WEBPACK_IMPORTED_MODULE_0__WebSocketBridge_js__","VueDjangoChannels","install","Vue","webSocketBridge","connect","listen","$channels","addListeners","$options","conf","channels","events","prefix","keys","func","bind","addEventListener","__binded","removeListeners","removeEventListener","addStreamHandlers","_this3","demultiplex","removeStreamHandlers","_this4","removeStreamHandler","removeHandlers","mixin","beforeCompile","beforeCreate","created","beforeDestroy","isWebSocket","constructor","CLOSING","isGlobalWebSocket","WebSocket","getDefaultOptions","maxReconnectionDelay","minReconnectionDelay","reconnectionDelayGrowFactor","connectionTimeout","maxRetries","Infinity","debug","bypassProperty","src","dst","set","initReconnectionDelay","config","Math","random","updateReconnectionDelay","previousDelay","newDelay","LEVEL_0_EVENTS","reassignEventListeners","ws","oldWs","listeners","type","_a","listener","ReconnectingWebsocket","connectingTimeout","reconnectDelay","retriesCount","shouldRetry","savedOnClose","log","params","_i","console","apply","concat","emitError","code","setTimeout","err","Error","error","fn","onerror","handleClose","close","indexOf","clearTimeout","onclose","reason","_b","_c","keepClosed","_d","fastClose","_e","delay","fakeCloseEvent_1","wasClean","some"],"mappings":"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","file":"vue-django-channels.js","sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine([], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"VueDjangoChannels\"] = factory();\n\telse\n\t\troot[\"VueDjangoChannels\"] = factory();\n})(this, function() {\nreturn \n\n\n// WEBPACK FOOTER //\n// webpack/universalModuleDefinition","(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine([], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"VueDjangoChannels\"] = factory();\n\telse\n\t\troot[\"VueDjangoChannels\"] = factory();\n})(this, function() {\nreturn /******/ (function(modules) { // webpackBootstrap\n/******/ \t// The module cache\n/******/ \tvar installedModules = {};\n/******/\n/******/ \t// The require function\n/******/ \tfunction __webpack_require__(moduleId) {\n/******/\n/******/ \t\t// Check if module is in cache\n/******/ \t\tif(installedModules[moduleId])\n/******/ \t\t\treturn installedModules[moduleId].exports;\n/******/\n/******/ \t\t// Create a new module (and put it into the cache)\n/******/ \t\tvar module = installedModules[moduleId] = {\n/******/ \t\t\ti: moduleId,\n/******/ \t\t\tl: false,\n/******/ \t\t\texports: {}\n/******/ \t\t};\n/******/\n/******/ \t\t// Execute the module function\n/******/ \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n/******/\n/******/ \t\t// Flag the module as loaded\n/******/ \t\tmodule.l = true;\n/******/\n/******/ \t\t// Return the exports of the module\n/******/ \t\treturn module.exports;\n/******/ \t}\n/******/\n/******/\n/******/ \t// expose the modules object (__webpack_modules__)\n/******/ \t__webpack_require__.m = modules;\n/******/\n/******/ \t// expose the module cache\n/******/ \t__webpack_require__.c = installedModules;\n/******/\n/******/ \t// identity function for calling harmony imports with the correct context\n/******/ \t__webpack_require__.i = function(value) { return value; };\n/******/\n/******/ \t// define getter function for harmony exports\n/******/ \t__webpack_require__.d = function(exports, name, getter) {\n/******/ \t\tif(!__webpack_require__.o(exports, name)) {\n/******/ \t\t\tObject.defineProperty(exports, name, {\n/******/ \t\t\t\tconfigurable: false,\n/******/ \t\t\t\tenumerable: true,\n/******/ \t\t\t\tget: getter\n/******/ \t\t\t});\n/******/ \t\t}\n/******/ \t};\n/******/\n/******/ \t// getDefaultExport function for compatibility with non-harmony modules\n/******/ \t__webpack_require__.n = function(module) {\n/******/ \t\tvar getter = module && module.__esModule ?\n/******/ \t\t\tfunction getDefault() { return module['default']; } :\n/******/ \t\t\tfunction getModuleExports() { return module; };\n/******/ \t\t__webpack_require__.d(getter, 'a', getter);\n/******/ \t\treturn getter;\n/******/ \t};\n/******/\n/******/ \t// Object.prototype.hasOwnProperty.call\n/******/ \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n/******/\n/******/ \t// __webpack_public_path__\n/******/ \t__webpack_require__.p = \"/dist/\";\n/******/\n/******/ \t// Load entry module and return exports\n/******/ \treturn __webpack_require__(__webpack_require__.s = 1);\n/******/ })\n/************************************************************************/\n/******/ ([\n/* 0 */\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n\"use strict\";\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_reconnecting_websocket__ = __webpack_require__(2);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_reconnecting_websocket___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0_reconnecting_websocket__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"a\", function() { return WebSocketBridge; });\nvar _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\n\n\n/**\r\n * Bridge between Channels and plain javascript.\r\n *\r\n * @example\r\n * const webSocketBridge = new WebSocketBridge();\r\n * webSocketBridge.connect();\r\n * webSocketBridge.listen(function(action, stream) {\r\n *   console.log(action, stream);\r\n * });\r\n */\n\nvar WebSocketBridge = function () {\n  function WebSocketBridge(options) {\n    _classCallCheck(this, WebSocketBridge);\n\n    /**\r\n     * The underlaying `ReconnectingWebSocket` instance.\r\n     * \r\n     * @type {ReconnectingWebSocket}\r\n     */\n    this.socket = null;\n    this.streams = {};\n    this.default_cb = null;\n    this.options = _extends({}, options);\n  }\n\n  /**\r\n   * Connect to the websocket server\r\n   *\r\n   * @param      {String}  [url]     The url of the websocket. Defaults to\r\n   * `window.location.host`\r\n   * @param      {String[]|String}  [protocols] Optional string or array of protocols.\r\n   * @param      {Object} options Object of options for [`reconnecting-websocket`](https://github.com/joewalnes/reconnecting-websocket#options-1).\r\n   * @example\r\n   * const webSocketBridge = new WebSocketBridge();\r\n   * webSocketBridge.connect();\r\n   */\n\n\n  _createClass(WebSocketBridge, [{\n    key: 'connect',\n    value: function connect(url, protocols, options) {\n      var _url = void 0;\n      // Use wss:// if running on https://\n      var scheme = window.location.protocol === 'https:' ? 'wss' : 'ws';\n      var base_url = scheme + '://' + window.location.host;\n      if (url === undefined) {\n        _url = base_url;\n      } else {\n        // Support relative URLs\n        if (url[0] == '/') {\n          _url = '' + base_url + url;\n        } else {\n          _url = url;\n        }\n      }\n      this.socket = new __WEBPACK_IMPORTED_MODULE_0_reconnecting_websocket___default.a(_url, protocols, options);\n    }\n\n    /**\r\n     * Starts listening for messages on the websocket, demultiplexing if necessary.\r\n     *\r\n     * @param      {Function}  [cb]         Callback to be execute when a message\r\n     * arrives. The callback will receive `action` and `stream` parameters\r\n     *\r\n     * @example\r\n     * const webSocketBridge = new WebSocketBridge();\r\n     * webSocketBridge.connect();\r\n     * webSocketBridge.listen(function(action, stream) {\r\n     *   console.log(action, stream);\r\n     * });\r\n     */\n\n  }, {\n    key: 'listen',\n    value: function listen(cb) {\n      var _this = this;\n\n      this.default_cb = cb;\n      this.socket.onmessage = function (event) {\n        var msg = JSON.parse(event.data);\n        var action = void 0;\n        var stream = void 0;\n\n        if (msg.stream !== undefined) {\n          action = msg.payload;\n          stream = msg.stream;\n          // this will call all registered callbacks for this stream\n          if (Array.isArray(_this.streams[stream])) {\n            _this.streams[stream].forEach(function (callback) {\n              callback ? callback(action, stream) : null;\n            });\n          }\n        } else {\n          action = msg;\n          stream = null;\n          _this.default_cb ? _this.default_cb(action, stream) : null;\n        }\n      };\n    }\n\n    /**\r\n     * Adds a 'stream handler' callback. Messages coming from the specified stream\r\n     * will call the specified callback. Streams can have multiple handlers that\r\n     * will all be called in sequence on receiving a message on the websocket.\r\n     *\r\n     * @param      {String}    stream  The stream name\r\n     * @param      {Function}  cb      Callback to be execute when a message\r\n     * arrives. The callback will receive `action` and `stream` parameters.\r\n       * @example\r\n     * const webSocketBridge = new WebSocketBridge();\r\n     * webSocketBridge.connect();\r\n     * webSocketBridge.listen();\r\n     * webSocketBridge.demultiplex('mystream', function(action, stream) {\r\n     *   console.log(action, stream);\r\n     * });\r\n     * webSocketBridge.demultiplex('myotherstream', function(action, stream) {\r\n     *   console.info(action, stream);\r\n     * });\r\n     */\n\n  }, {\n    key: 'demultiplex',\n    value: function demultiplex(stream, cb) {\n      if (Array.isArray(this.streams[stream])) {\n        this.streams[stream].push(cb);\n      } else {\n        // add the first array element\n        this.streams[stream] = [cb];\n      }\n    }\n\n    /**\r\n     * Removes a 'stream handler' callback.\r\n     *\r\n     * @param      {String}    stream  The stream name\r\n     * @param      {Function}  cb      Callback to be removed\r\n     */\n\n  }, {\n    key: 'removeStreamHandler',\n    value: function removeStreamHandler(stream, cb) {\n      if (Array.isArray(this.streams[stream])) {\n        this.streams[stream] = this.streams[stream].filter(function (callback) {\n          return callback !== cb;\n        });\n\n        if (this.streams[stream].length === 0) {\n          delete this.streams[stream];\n        }\n      }\n    }\n\n    /**\r\n     * Sends a message to the reply channel.\r\n     *\r\n     * @param      {Object}  msg     The message\r\n     *\r\n     * @example\r\n     * webSocketBridge.send({prop1: 'value1', prop2: 'value1'});\r\n     */\n\n  }, {\n    key: 'send',\n    value: function send(msg) {\n      this.socket.send(JSON.stringify(msg));\n    }\n\n    /**\r\n     * Returns an object to send messages to a specific stream\r\n     *\r\n     * @param      {String}  stream  The stream name\r\n     * @return     {Object}  convenience object to send messages to `stream`.\r\n     * @example\r\n     * webSocketBridge.stream('mystream').send({prop1: 'value1', prop2: 'value1'})\r\n     */\n\n  }, {\n    key: 'stream',\n    value: function stream(_stream) {\n      var _this2 = this;\n\n      return {\n        send: function send(action) {\n          var msg = {\n            stream: _stream,\n            payload: action\n          };\n          _this2.socket.send(JSON.stringify(msg));\n        }\n      };\n    }\n  }]);\n\n  return WebSocketBridge;\n}();\n\n\n\n/***/ }),\n/* 1 */\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n\"use strict\";\nObject.defineProperty(__webpack_exports__, \"__esModule\", { value: true });\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__WebSocketBridge_js__ = __webpack_require__(0);\n// based on [vue-websocket](https://github.com/icebob/vue-websocket)\n\n\n\nvar VueDjangoChannels = {\n    install: function install(Vue, url, protocols, options) {\n\n        var webSocketBridge = new __WEBPACK_IMPORTED_MODULE_0__WebSocketBridge_js__[\"a\" /* WebSocketBridge */]();\n\n        webSocketBridge.connect(url, protocols, options);\n        webSocketBridge.listen();\n\n        Vue.prototype.$channels = webSocketBridge;\n\n        var addListeners = function addListeners() {\n            var _this = this;\n\n            if (this.$options[\"channels\"]) {\n                var conf = this.$options.channels;\n\n                if (conf.events) {\n                    var prefix = conf.prefix || \"\";\n                    Object.keys(conf.events).forEach(function (key) {\n                        var func = conf.events[key].bind(_this);\n                        _this.$channels.socket.addEventListener(prefix + key, func);\n                        conf.events[key].__binded = func;\n                    });\n                }\n            }\n        };\n\n        var removeListeners = function removeListeners() {\n            var _this2 = this;\n\n            if (this.$options[\"channels\"]) {\n                var conf = this.$options.channels;\n\n                if (conf.events) {\n                    var prefix = conf.prefix || \"\";\n                    Object.keys(conf.events).forEach(function (key) {\n                        _this2.$channels.socket.removeEventListener(prefix + key, conf.events[key].__binded);\n                    });\n                }\n            }\n        };\n\n        var addStreamHandlers = function addStreamHandlers() {\n            var _this3 = this;\n\n            if (this.$options[\"channels\"]) {\n                var conf = this.$options.channels;\n\n                if (conf.streams) {\n                    Object.keys(conf.streams).forEach(function (stream) {\n                        var func = conf.streams[stream].bind(_this3);\n                        _this3.$channels.demultiplex(stream, func);\n                    });\n                }\n            }\n        };\n\n        var removeStreamHandlers = function removeStreamHandlers() {\n            var _this4 = this;\n\n            if (this.$options[\"channels\"]) {\n                var conf = this.$options.channels;\n\n                if (conf.streams) {\n                    Object.keys(conf.streams).forEach(function (stream) {\n                        _this4.$channels.removeStreamHandler(stream, conf.streams[stream].__binded);\n                    });\n                }\n            }\n        };\n\n        var removeHandlers = function removeHandlers() {\n            removeListeners();\n            removeStreamHandlers();\n        };\n\n        Vue.mixin({\n            // Vue v1.x\n            beforeCompile: addListeners,\n            // Vue v2.x\n            beforeCreate: addListeners,\n\n            created: addStreamHandlers,\n\n            beforeDestroy: removeHandlers\n        });\n    }\n};\n\n/* harmony default export */ __webpack_exports__[\"default\"] = (VueDjangoChannels);\n\n/***/ }),\n/* 2 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\nvar isWebSocket = function (constructor) {\n    return constructor && constructor.CLOSING === 2;\n};\nvar isGlobalWebSocket = function () {\n    return typeof WebSocket !== 'undefined' && isWebSocket(WebSocket);\n};\nvar getDefaultOptions = function () { return ({\n    constructor: isGlobalWebSocket() ? WebSocket : null,\n    maxReconnectionDelay: 10000,\n    minReconnectionDelay: 1500,\n    reconnectionDelayGrowFactor: 1.3,\n    connectionTimeout: 4000,\n    maxRetries: Infinity,\n    debug: false,\n}); };\nvar bypassProperty = function (src, dst, name) {\n    Object.defineProperty(dst, name, {\n        get: function () { return src[name]; },\n        set: function (value) { src[name] = value; },\n        enumerable: true,\n        configurable: true,\n    });\n};\nvar initReconnectionDelay = function (config) {\n    return (config.minReconnectionDelay + Math.random() * config.minReconnectionDelay);\n};\nvar updateReconnectionDelay = function (config, previousDelay) {\n    var newDelay = previousDelay * config.reconnectionDelayGrowFactor;\n    return (newDelay > config.maxReconnectionDelay)\n        ? config.maxReconnectionDelay\n        : newDelay;\n};\nvar LEVEL_0_EVENTS = ['onopen', 'onclose', 'onmessage', 'onerror'];\nvar reassignEventListeners = function (ws, oldWs, listeners) {\n    Object.keys(listeners).forEach(function (type) {\n        listeners[type].forEach(function (_a) {\n            var listener = _a[0], options = _a[1];\n            ws.addEventListener(type, listener, options);\n        });\n    });\n    if (oldWs) {\n        LEVEL_0_EVENTS.forEach(function (name) { ws[name] = oldWs[name]; });\n    }\n};\nvar ReconnectingWebsocket = function (url, protocols, options) {\n    var _this = this;\n    if (options === void 0) { options = {}; }\n    var ws;\n    var connectingTimeout;\n    var reconnectDelay = 0;\n    var retriesCount = 0;\n    var shouldRetry = true;\n    var savedOnClose = null;\n    var listeners = {};\n    // require new to construct\n    if (!(this instanceof ReconnectingWebsocket)) {\n        throw new TypeError(\"Failed to construct 'ReconnectingWebSocket': Please use the 'new' operator\");\n    }\n    // Set config. Not using `Object.assign` because of IE11\n    var config = getDefaultOptions();\n    Object.keys(config)\n        .filter(function (key) { return options.hasOwnProperty(key); })\n        .forEach(function (key) { return config[key] = options[key]; });\n    if (!isWebSocket(config.constructor)) {\n        throw new TypeError('Invalid WebSocket constructor. Set `options.constructor`');\n    }\n    var log = config.debug ? function () {\n        var params = [];\n        for (var _i = 0; _i < arguments.length; _i++) {\n            params[_i - 0] = arguments[_i];\n        }\n        return console.log.apply(console, ['RWS:'].concat(params));\n    } : function () { };\n    /**\n     * Not using dispatchEvent, otherwise we must use a DOM Event object\n     * Deferred because we want to handle the close event before this\n     */\n    var emitError = function (code, msg) { return setTimeout(function () {\n        var err = new Error(msg);\n        err.code = code;\n        if (Array.isArray(listeners.error)) {\n            listeners.error.forEach(function (_a) {\n                var fn = _a[0];\n                return fn(err);\n            });\n        }\n        if (ws.onerror) {\n            ws.onerror(err);\n        }\n    }, 0); };\n    var handleClose = function () {\n        log('close');\n        retriesCount++;\n        log('retries count:', retriesCount);\n        if (retriesCount > config.maxRetries) {\n            emitError('EHOSTDOWN', 'Too many failed connection attempts');\n            return;\n        }\n        if (!reconnectDelay) {\n            reconnectDelay = initReconnectionDelay(config);\n        }\n        else {\n            reconnectDelay = updateReconnectionDelay(config, reconnectDelay);\n        }\n        log('reconnectDelay:', reconnectDelay);\n        if (shouldRetry) {\n            setTimeout(connect, reconnectDelay);\n        }\n    };\n    var connect = function () {\n        log('connect');\n        var oldWs = ws;\n        ws = new config.constructor(url, protocols);\n        connectingTimeout = setTimeout(function () {\n            log('timeout');\n            ws.close();\n            emitError('ETIMEDOUT', 'Connection timeout');\n        }, config.connectionTimeout);\n        log('bypass properties');\n        for (var key in ws) {\n            // @todo move to constant\n            if (['addEventListener', 'removeEventListener', 'close', 'send'].indexOf(key) < 0) {\n                bypassProperty(ws, _this, key);\n            }\n        }\n        ws.addEventListener('open', function () {\n            clearTimeout(connectingTimeout);\n            log('open');\n            reconnectDelay = initReconnectionDelay(config);\n            log('reconnectDelay:', reconnectDelay);\n            retriesCount = 0;\n        });\n        ws.addEventListener('close', handleClose);\n        reassignEventListeners(ws, oldWs, listeners);\n        // because when closing with fastClose=true, it is saved and set to null to avoid double calls\n        ws.onclose = ws.onclose || savedOnClose;\n        savedOnClose = null;\n    };\n    log('init');\n    connect();\n    this.close = function (code, reason, _a) {\n        if (code === void 0) { code = 1000; }\n        if (reason === void 0) { reason = ''; }\n        var _b = _a === void 0 ? {} : _a, _c = _b.keepClosed, keepClosed = _c === void 0 ? false : _c, _d = _b.fastClose, fastClose = _d === void 0 ? true : _d, _e = _b.delay, delay = _e === void 0 ? 0 : _e;\n        if (delay) {\n            reconnectDelay = delay;\n        }\n        shouldRetry = !keepClosed;\n        ws.close(code, reason);\n        if (fastClose) {\n            var fakeCloseEvent_1 = {\n                code: code,\n                reason: reason,\n                wasClean: true,\n            };\n            // execute close listeners soon with a fake closeEvent\n            // and remove them from the WS instance so they\n            // don't get fired on the real close.\n            handleClose();\n            ws.removeEventListener('close', handleClose);\n            // run and remove level2\n            if (Array.isArray(listeners.close)) {\n                listeners.close.forEach(function (_a) {\n                    var listener = _a[0], options = _a[1];\n                    listener(fakeCloseEvent_1);\n                    ws.removeEventListener('close', listener, options);\n                });\n            }\n            // run and remove level0\n            if (ws.onclose) {\n                savedOnClose = ws.onclose;\n                ws.onclose(fakeCloseEvent_1);\n                ws.onclose = null;\n            }\n        }\n    };\n    this.send = function (data) {\n        ws.send(data);\n    };\n    this.addEventListener = function (type, listener, options) {\n        if (Array.isArray(listeners[type])) {\n            if (!listeners[type].some(function (_a) {\n                var l = _a[0];\n                return l === listener;\n            })) {\n                listeners[type].push([listener, options]);\n            }\n        }\n        else {\n            listeners[type] = [[listener, options]];\n        }\n        ws.addEventListener(type, listener, options);\n    };\n    this.removeEventListener = function (type, listener, options) {\n        if (Array.isArray(listeners[type])) {\n            listeners[type] = listeners[type].filter(function (_a) {\n                var l = _a[0];\n                return l !== listener;\n            });\n        }\n        ws.removeEventListener(type, listener, options);\n    };\n};\nmodule.exports = ReconnectingWebsocket;\n\n\n/***/ })\n/******/ ]);\n});\n\n\n// WEBPACK FOOTER //\n// vue-django-channels.js"," \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId])\n \t\t\treturn installedModules[moduleId].exports;\n\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// identity function for calling harmony imports with the correct context\n \t__webpack_require__.i = function(value) { return value; };\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, {\n \t\t\t\tconfigurable: false,\n \t\t\t\tenumerable: true,\n \t\t\t\tget: getter\n \t\t\t});\n \t\t}\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"/dist/\";\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = 1);\n\n\n\n// WEBPACK FOOTER //\n// webpack/bootstrap 85431114a5feeaa4d259","import ReconnectingWebSocket from 'reconnecting-websocket';\r\n\r\n\r\n/**\r\n * Bridge between Channels and plain javascript.\r\n *\r\n * @example\r\n * const webSocketBridge = new WebSocketBridge();\r\n * webSocketBridge.connect();\r\n * webSocketBridge.listen(function(action, stream) {\r\n *   console.log(action, stream);\r\n * });\r\n */\r\nexport class WebSocketBridge {\r\n  constructor(options) {\r\n    /**\r\n     * The underlaying `ReconnectingWebSocket` instance.\r\n     * \r\n     * @type {ReconnectingWebSocket}\r\n     */\r\n    this.socket = null;\r\n    this.streams = {};\r\n    this.default_cb = null;\r\n    this.options = {...options};\r\n  }\r\n\r\n  /**\r\n   * Connect to the websocket server\r\n   *\r\n   * @param      {String}  [url]     The url of the websocket. Defaults to\r\n   * `window.location.host`\r\n   * @param      {String[]|String}  [protocols] Optional string or array of protocols.\r\n   * @param      {Object} options Object of options for [`reconnecting-websocket`](https://github.com/joewalnes/reconnecting-websocket#options-1).\r\n   * @example\r\n   * const webSocketBridge = new WebSocketBridge();\r\n   * webSocketBridge.connect();\r\n   */\r\n  connect(url, protocols, options) {\r\n    let _url;\r\n    // Use wss:// if running on https://\r\n    const scheme = window.location.protocol === 'https:' ? 'wss' : 'ws';\r\n    const base_url = `${scheme}://${window.location.host}`;\r\n    if (url === undefined) {\r\n      _url = base_url;\r\n    } else {\r\n      // Support relative URLs\r\n      if (url[0] == '/') {\r\n        _url = `${base_url}${url}`;\r\n      } else {\r\n        _url = url;\r\n      }\r\n    }\r\n    this.socket = new ReconnectingWebSocket(_url, protocols, options);\r\n  }\r\n\r\n  /**\r\n   * Starts listening for messages on the websocket, demultiplexing if necessary.\r\n   *\r\n   * @param      {Function}  [cb]         Callback to be execute when a message\r\n   * arrives. The callback will receive `action` and `stream` parameters\r\n   *\r\n   * @example\r\n   * const webSocketBridge = new WebSocketBridge();\r\n   * webSocketBridge.connect();\r\n   * webSocketBridge.listen(function(action, stream) {\r\n   *   console.log(action, stream);\r\n   * });\r\n   */\r\n  listen(cb) {\r\n    this.default_cb = cb;\r\n    this.socket.onmessage = (event) => {\r\n      const msg = JSON.parse(event.data);\r\n      let action;\r\n      let stream;\r\n\r\n      if (msg.stream !== undefined) {\r\n        action = msg.payload;\r\n        stream = msg.stream;\r\n        // this will call all registered callbacks for this stream\r\n        if(Array.isArray(this.streams[stream])) {\r\n          this.streams[stream].forEach(function(callback) {\r\n            callback ? callback(action, stream) : null\r\n          })\r\n        }\r\n      } else {\r\n        action = msg;\r\n        stream = null;\r\n        this.default_cb ? this.default_cb(action, stream) : null;\r\n      }\r\n    };\r\n  }\r\n\r\n  /**\r\n   * Adds a 'stream handler' callback. Messages coming from the specified stream\r\n   * will call the specified callback. Streams can have multiple handlers that\r\n   * will all be called in sequence on receiving a message on the websocket.\r\n   *\r\n   * @param      {String}    stream  The stream name\r\n   * @param      {Function}  cb      Callback to be execute when a message\r\n   * arrives. The callback will receive `action` and `stream` parameters.\r\n\r\n   * @example\r\n   * const webSocketBridge = new WebSocketBridge();\r\n   * webSocketBridge.connect();\r\n   * webSocketBridge.listen();\r\n   * webSocketBridge.demultiplex('mystream', function(action, stream) {\r\n   *   console.log(action, stream);\r\n   * });\r\n   * webSocketBridge.demultiplex('myotherstream', function(action, stream) {\r\n   *   console.info(action, stream);\r\n   * });\r\n   */\r\n  demultiplex(stream, cb) {\r\n    if(Array.isArray(this.streams[stream])) {\r\n      this.streams[stream].push(cb)\r\n    } else {\r\n      // add the first array element\r\n      this.streams[stream] = [cb];\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Removes a 'stream handler' callback.\r\n   *\r\n   * @param      {String}    stream  The stream name\r\n   * @param      {Function}  cb      Callback to be removed\r\n   */\r\n  removeStreamHandler(stream, cb) {\r\n    if(Array.isArray(this.streams[stream])) {\r\n      this.streams[stream] = this.streams[stream].filter(function(callback) {\r\n        return callback !== cb\r\n      })\r\n\r\n      if (this.streams[stream].length === 0) {\r\n      \tdelete this.streams[stream]\r\n      }\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Sends a message to the reply channel.\r\n   *\r\n   * @param      {Object}  msg     The message\r\n   *\r\n   * @example\r\n   * webSocketBridge.send({prop1: 'value1', prop2: 'value1'});\r\n   */\r\n  send(msg) {\r\n    this.socket.send(JSON.stringify(msg));\r\n  }\r\n\r\n  /**\r\n   * Returns an object to send messages to a specific stream\r\n   *\r\n   * @param      {String}  stream  The stream name\r\n   * @return     {Object}  convenience object to send messages to `stream`.\r\n   * @example\r\n   * webSocketBridge.stream('mystream').send({prop1: 'value1', prop2: 'value1'})\r\n   */\r\n  stream(stream) {\r\n    return {\r\n      send: (action) => {\r\n        const msg = {\r\n          stream,\r\n          payload: action\r\n        }\r\n        this.socket.send(JSON.stringify(msg));\r\n      }\r\n    }\r\n  }\r\n\r\n}\n\n\n// WEBPACK FOOTER //\n// ./src/WebSocketBridge.js","// based on [vue-websocket](https://github.com/icebob/vue-websocket)\r\n\r\nimport { WebSocketBridge } from './WebSocketBridge.js';\r\n\r\nlet VueDjangoChannels = {\r\n\r\n    install(Vue, url, protocols, options) {\r\n\r\n        let webSocketBridge = new WebSocketBridge()\r\n\r\n        webSocketBridge.connect(url, protocols, options);\r\n        webSocketBridge.listen();\r\n\r\n        Vue.prototype.$channels = webSocketBridge;\r\n\r\n        let addListeners = function () {\r\n            if (this.$options[\"channels\"]) {\r\n                let conf = this.$options.channels;\r\n\r\n                if (conf.events) {\r\n                    let prefix = conf.prefix || \"\";\r\n                    Object.keys(conf.events).forEach((key) => {\r\n                        let func = conf.events[key].bind(this);\r\n                        this.$channels.socket.addEventListener(prefix + key, func);\r\n                        conf.events[key].__binded = func;\r\n                    });\r\n                }\r\n            }\r\n        };\r\n\r\n        let removeListeners = function () {\r\n            if (this.$options[\"channels\"]) {\r\n                let conf = this.$options.channels;\r\n\r\n                if (conf.events) {\r\n                    let prefix = conf.prefix || \"\";\r\n                    Object.keys(conf.events).forEach((key) => {\r\n                        this.$channels.socket.removeEventListener(prefix + key, conf.events[key].__binded);\r\n                    });\r\n                }\r\n            }\r\n        };\r\n\r\n        let addStreamHandlers = function () {\r\n            if (this.$options[\"channels\"]) {\r\n                let conf = this.$options.channels;\r\n\r\n                if (conf.streams) {\r\n                    Object.keys(conf.streams).forEach((stream) => {\r\n                        let func = conf.streams[stream].bind(this);\r\n                        this.$channels.demultiplex(stream, func);\r\n                    });\r\n                }\r\n            }\r\n        };\r\n\r\n        let removeStreamHandlers = function () {\r\n            if (this.$options[\"channels\"]) {\r\n                let conf = this.$options.channels;\r\n\r\n                if (conf.streams) {\r\n                    Object.keys(conf.streams).forEach((stream) => {\r\n                        this.$channels.removeStreamHandler(stream, conf.streams[stream].__binded);\r\n                    });\r\n                }\r\n            }\r\n        };\r\n\r\n        let removeHandlers = function () {\r\n            removeListeners();\r\n            removeStreamHandlers();\r\n        };\r\n\r\n        Vue.mixin({\r\n            // Vue v1.x\r\n            beforeCompile: addListeners,\r\n            // Vue v2.x\r\n            beforeCreate: addListeners,\r\n\r\n            created: addStreamHandlers,\r\n\r\n            beforeDestroy: removeHandlers\r\n        });\r\n    }\r\n};\r\n\r\nexport default VueDjangoChannels;\r\n\n\n\n// WEBPACK FOOTER //\n// ./src/index.js","\"use strict\";\nvar isWebSocket = function (constructor) {\n    return constructor && constructor.CLOSING === 2;\n};\nvar isGlobalWebSocket = function () {\n    return typeof WebSocket !== 'undefined' && isWebSocket(WebSocket);\n};\nvar getDefaultOptions = function () { return ({\n    constructor: isGlobalWebSocket() ? WebSocket : null,\n    maxReconnectionDelay: 10000,\n    minReconnectionDelay: 1500,\n    reconnectionDelayGrowFactor: 1.3,\n    connectionTimeout: 4000,\n    maxRetries: Infinity,\n    debug: false,\n}); };\nvar bypassProperty = function (src, dst, name) {\n    Object.defineProperty(dst, name, {\n        get: function () { return src[name]; },\n        set: function (value) { src[name] = value; },\n        enumerable: true,\n        configurable: true,\n    });\n};\nvar initReconnectionDelay = function (config) {\n    return (config.minReconnectionDelay + Math.random() * config.minReconnectionDelay);\n};\nvar updateReconnectionDelay = function (config, previousDelay) {\n    var newDelay = previousDelay * config.reconnectionDelayGrowFactor;\n    return (newDelay > config.maxReconnectionDelay)\n        ? config.maxReconnectionDelay\n        : newDelay;\n};\nvar LEVEL_0_EVENTS = ['onopen', 'onclose', 'onmessage', 'onerror'];\nvar reassignEventListeners = function (ws, oldWs, listeners) {\n    Object.keys(listeners).forEach(function (type) {\n        listeners[type].forEach(function (_a) {\n            var listener = _a[0], options = _a[1];\n            ws.addEventListener(type, listener, options);\n        });\n    });\n    if (oldWs) {\n        LEVEL_0_EVENTS.forEach(function (name) { ws[name] = oldWs[name]; });\n    }\n};\nvar ReconnectingWebsocket = function (url, protocols, options) {\n    var _this = this;\n    if (options === void 0) { options = {}; }\n    var ws;\n    var connectingTimeout;\n    var reconnectDelay = 0;\n    var retriesCount = 0;\n    var shouldRetry = true;\n    var savedOnClose = null;\n    var listeners = {};\n    // require new to construct\n    if (!(this instanceof ReconnectingWebsocket)) {\n        throw new TypeError(\"Failed to construct 'ReconnectingWebSocket': Please use the 'new' operator\");\n    }\n    // Set config. Not using `Object.assign` because of IE11\n    var config = getDefaultOptions();\n    Object.keys(config)\n        .filter(function (key) { return options.hasOwnProperty(key); })\n        .forEach(function (key) { return config[key] = options[key]; });\n    if (!isWebSocket(config.constructor)) {\n        throw new TypeError('Invalid WebSocket constructor. Set `options.constructor`');\n    }\n    var log = config.debug ? function () {\n        var params = [];\n        for (var _i = 0; _i < arguments.length; _i++) {\n            params[_i - 0] = arguments[_i];\n        }\n        return console.log.apply(console, ['RWS:'].concat(params));\n    } : function () { };\n    /**\n     * Not using dispatchEvent, otherwise we must use a DOM Event object\n     * Deferred because we want to handle the close event before this\n     */\n    var emitError = function (code, msg) { return setTimeout(function () {\n        var err = new Error(msg);\n        err.code = code;\n        if (Array.isArray(listeners.error)) {\n            listeners.error.forEach(function (_a) {\n                var fn = _a[0];\n                return fn(err);\n            });\n        }\n        if (ws.onerror) {\n            ws.onerror(err);\n        }\n    }, 0); };\n    var handleClose = function () {\n        log('close');\n        retriesCount++;\n        log('retries count:', retriesCount);\n        if (retriesCount > config.maxRetries) {\n            emitError('EHOSTDOWN', 'Too many failed connection attempts');\n            return;\n        }\n        if (!reconnectDelay) {\n            reconnectDelay = initReconnectionDelay(config);\n        }\n        else {\n            reconnectDelay = updateReconnectionDelay(config, reconnectDelay);\n        }\n        log('reconnectDelay:', reconnectDelay);\n        if (shouldRetry) {\n            setTimeout(connect, reconnectDelay);\n        }\n    };\n    var connect = function () {\n        log('connect');\n        var oldWs = ws;\n        ws = new config.constructor(url, protocols);\n        connectingTimeout = setTimeout(function () {\n            log('timeout');\n            ws.close();\n            emitError('ETIMEDOUT', 'Connection timeout');\n        }, config.connectionTimeout);\n        log('bypass properties');\n        for (var key in ws) {\n            // @todo move to constant\n            if (['addEventListener', 'removeEventListener', 'close', 'send'].indexOf(key) < 0) {\n                bypassProperty(ws, _this, key);\n            }\n        }\n        ws.addEventListener('open', function () {\n            clearTimeout(connectingTimeout);\n            log('open');\n            reconnectDelay = initReconnectionDelay(config);\n            log('reconnectDelay:', reconnectDelay);\n            retriesCount = 0;\n        });\n        ws.addEventListener('close', handleClose);\n        reassignEventListeners(ws, oldWs, listeners);\n        // because when closing with fastClose=true, it is saved and set to null to avoid double calls\n        ws.onclose = ws.onclose || savedOnClose;\n        savedOnClose = null;\n    };\n    log('init');\n    connect();\n    this.close = function (code, reason, _a) {\n        if (code === void 0) { code = 1000; }\n        if (reason === void 0) { reason = ''; }\n        var _b = _a === void 0 ? {} : _a, _c = _b.keepClosed, keepClosed = _c === void 0 ? false : _c, _d = _b.fastClose, fastClose = _d === void 0 ? true : _d, _e = _b.delay, delay = _e === void 0 ? 0 : _e;\n        if (delay) {\n            reconnectDelay = delay;\n        }\n        shouldRetry = !keepClosed;\n        ws.close(code, reason);\n        if (fastClose) {\n            var fakeCloseEvent_1 = {\n                code: code,\n                reason: reason,\n                wasClean: true,\n            };\n            // execute close listeners soon with a fake closeEvent\n            // and remove them from the WS instance so they\n            // don't get fired on the real close.\n            handleClose();\n            ws.removeEventListener('close', handleClose);\n            // run and remove level2\n            if (Array.isArray(listeners.close)) {\n                listeners.close.forEach(function (_a) {\n                    var listener = _a[0], options = _a[1];\n                    listener(fakeCloseEvent_1);\n                    ws.removeEventListener('close', listener, options);\n                });\n            }\n            // run and remove level0\n            if (ws.onclose) {\n                savedOnClose = ws.onclose;\n                ws.onclose(fakeCloseEvent_1);\n                ws.onclose = null;\n            }\n        }\n    };\n    this.send = function (data) {\n        ws.send(data);\n    };\n    this.addEventListener = function (type, listener, options) {\n        if (Array.isArray(listeners[type])) {\n            if (!listeners[type].some(function (_a) {\n                var l = _a[0];\n                return l === listener;\n            })) {\n                listeners[type].push([listener, options]);\n            }\n        }\n        else {\n            listeners[type] = [[listener, options]];\n        }\n        ws.addEventListener(type, listener, options);\n    };\n    this.removeEventListener = function (type, listener, options) {\n        if (Array.isArray(listeners[type])) {\n            listeners[type] = listeners[type].filter(function (_a) {\n                var l = _a[0];\n                return l !== listener;\n            });\n        }\n        ws.removeEventListener(type, listener, options);\n    };\n};\nmodule.exports = ReconnectingWebsocket;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/reconnecting-websocket/dist/index.js\n// module id = 2\n// module chunks = 0"],"sourceRoot":""}