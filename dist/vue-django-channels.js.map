{"version":3,"sources":["webpack:///vue-django-channels.js","webpack:///webpack/bootstrap 1597307d271c0bece0d9","webpack:///./~/django-channels/lib/index.js","webpack:///./src/index.js","webpack:///./~/reconnecting-websocket/dist/index.js"],"names":["modules","__webpack_require__","moduleId","installedModules","exports","module","i","l","call","m","c","value","d","name","getter","o","Object","defineProperty","configurable","enumerable","get","n","__esModule","object","property","prototype","hasOwnProperty","p","s","_classCallCheck","instance","Constructor","TypeError","WebSocketBridge","undefined","_extends","assign","target","arguments","length","source","key","_createClass","defineProperties","props","descriptor","writable","protoProps","staticProps","_reconnectingWebsocket","_reconnectingWebsocket2","obj","default","options","this","socket","streams","default_cb","url","protocols","_url","scheme","window","location","protocol","base_url","host","cb","_this","onmessage","event","msg","JSON","parse","data","action","stream","payload","stream_cb","send","stringify","_stream","_this2","__webpack_exports__","__WEBPACK_IMPORTED_MODULE_0_django_channels__","install","Vue","webSocketBridge","connect","listen","$channels","$socket","addListeners","$options","conf","channels","events","prefix","keys","forEach","func","bind","addEventListener","__binded","removeListeners","removeEventListener","addStreamHandlers","_this3","demultiplex","mixin","beforeCompile","beforeCreate","created","beforeDestroy","isWebSocket","constructor","CLOSING","isGlobalWebSocket","WebSocket","getDefaultOptions","maxReconnectionDelay","minReconnectionDelay","reconnectionDelayGrowFactor","connectionTimeout","maxRetries","Infinity","debug","bypassProperty","src","dst","set","initReconnectionDelay","config","Math","random","updateReconnectionDelay","previousDelay","newDelay","LEVEL_0_EVENTS","reassignEventListeners","ws","oldWs","listeners","type","_a","listener","ReconnectingWebsocket","connectingTimeout","reconnectDelay","retriesCount","shouldRetry","savedOnClose","filter","log","params","_i","console","apply","concat","emitError","code","setTimeout","err","Error","Array","isArray","error","fn","onerror","handleClose","close","indexOf","clearTimeout","onclose","reason","_b","_c","keepClosed","_d","fastClose","_e","delay","fakeCloseEvent_1","wasClean","some","push"],"mappings":"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","file":"vue-django-channels.js","sourcesContent":["/******/ (function(modules) { // webpackBootstrap\n/******/ \t// The module cache\n/******/ \tvar installedModules = {};\n/******/\n/******/ \t// The require function\n/******/ \tfunction __webpack_require__(moduleId) {\n/******/\n/******/ \t\t// Check if module is in cache\n/******/ \t\tif(installedModules[moduleId])\n/******/ \t\t\treturn installedModules[moduleId].exports;\n/******/\n/******/ \t\t// Create a new module (and put it into the cache)\n/******/ \t\tvar module = installedModules[moduleId] = {\n/******/ \t\t\ti: moduleId,\n/******/ \t\t\tl: false,\n/******/ \t\t\texports: {}\n/******/ \t\t};\n/******/\n/******/ \t\t// Execute the module function\n/******/ \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n/******/\n/******/ \t\t// Flag the module as loaded\n/******/ \t\tmodule.l = true;\n/******/\n/******/ \t\t// Return the exports of the module\n/******/ \t\treturn module.exports;\n/******/ \t}\n/******/\n/******/\n/******/ \t// expose the modules object (__webpack_modules__)\n/******/ \t__webpack_require__.m = modules;\n/******/\n/******/ \t// expose the module cache\n/******/ \t__webpack_require__.c = installedModules;\n/******/\n/******/ \t// identity function for calling harmony imports with the correct context\n/******/ \t__webpack_require__.i = function(value) { return value; };\n/******/\n/******/ \t// define getter function for harmony exports\n/******/ \t__webpack_require__.d = function(exports, name, getter) {\n/******/ \t\tif(!__webpack_require__.o(exports, name)) {\n/******/ \t\t\tObject.defineProperty(exports, name, {\n/******/ \t\t\t\tconfigurable: false,\n/******/ \t\t\t\tenumerable: true,\n/******/ \t\t\t\tget: getter\n/******/ \t\t\t});\n/******/ \t\t}\n/******/ \t};\n/******/\n/******/ \t// getDefaultExport function for compatibility with non-harmony modules\n/******/ \t__webpack_require__.n = function(module) {\n/******/ \t\tvar getter = module && module.__esModule ?\n/******/ \t\t\tfunction getDefault() { return module['default']; } :\n/******/ \t\t\tfunction getModuleExports() { return module; };\n/******/ \t\t__webpack_require__.d(getter, 'a', getter);\n/******/ \t\treturn getter;\n/******/ \t};\n/******/\n/******/ \t// Object.prototype.hasOwnProperty.call\n/******/ \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n/******/\n/******/ \t// __webpack_public_path__\n/******/ \t__webpack_require__.p = \"/dist/\";\n/******/\n/******/ \t// Load entry module and return exports\n/******/ \treturn __webpack_require__(__webpack_require__.s = 1);\n/******/ })\n/************************************************************************/\n/******/ ([\n/* 0 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.WebSocketBridge = undefined;\n\nvar _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nvar _reconnectingWebsocket = __webpack_require__(2);\n\nvar _reconnectingWebsocket2 = _interopRequireDefault(_reconnectingWebsocket);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\n/**\n * Bridge between Channels and plain javascript.\n *\n * @example\n * const webSocketBridge = new WebSocketBridge();\n * webSocketBridge.connect();\n * webSocketBridge.listen(function(action, stream) {\n *   console.log(action, stream);\n * });\n */\nvar WebSocketBridge = function () {\n  function WebSocketBridge(options) {\n    _classCallCheck(this, WebSocketBridge);\n\n    /**\n     * The underlaying `ReconnectingWebSocket` instance.\n     * \n     * @type {ReconnectingWebSocket}\n     */\n    this.socket = null;\n    this.streams = {};\n    this.default_cb = null;\n    this.options = _extends({}, options);\n  }\n\n  /**\n   * Connect to the websocket server\n   *\n   * @param      {String}  [url]     The url of the websocket. Defaults to\n   * `window.location.host`\n   * @param      {String[]|String}  [protocols] Optional string or array of protocols.\n   * @param      {Object} options Object of options for [`reconnecting-websocket`](https://github.com/joewalnes/reconnecting-websocket#options-1).\n   * @example\n   * const webSocketBridge = new WebSocketBridge();\n   * webSocketBridge.connect();\n   */\n\n\n  _createClass(WebSocketBridge, [{\n    key: 'connect',\n    value: function connect(url, protocols, options) {\n      var _url = void 0;\n      // Use wss:// if running on https://\n      var scheme = window.location.protocol === 'https:' ? 'wss' : 'ws';\n      var base_url = scheme + '://' + window.location.host;\n      if (url === undefined) {\n        _url = base_url;\n      } else {\n        // Support relative URLs\n        if (url[0] == '/') {\n          _url = '' + base_url + url;\n        } else {\n          _url = url;\n        }\n      }\n      this.socket = new _reconnectingWebsocket2.default(_url, protocols, options);\n    }\n\n    /**\n     * Starts listening for messages on the websocket, demultiplexing if necessary.\n     *\n     * @param      {Function}  [cb]         Callback to be execute when a message\n     * arrives. The callback will receive `action` and `stream` parameters\n     *\n     * @example\n     * const webSocketBridge = new WebSocketBridge();\n     * webSocketBridge.connect();\n     * webSocketBridge.listen(function(action, stream) {\n     *   console.log(action, stream);\n     * });\n     */\n\n  }, {\n    key: 'listen',\n    value: function listen(cb) {\n      var _this = this;\n\n      this.default_cb = cb;\n      this.socket.onmessage = function (event) {\n        var msg = JSON.parse(event.data);\n        var action = void 0;\n        var stream = void 0;\n\n        if (msg.stream !== undefined) {\n          action = msg.payload;\n          stream = msg.stream;\n          var stream_cb = _this.streams[stream];\n          stream_cb ? stream_cb(action, stream) : null;\n        } else {\n          action = msg;\n          stream = null;\n          _this.default_cb ? _this.default_cb(action, stream) : null;\n        }\n      };\n    }\n\n    /**\n     * Adds a 'stream handler' callback. Messages coming from the specified stream\n     * will call the specified callback.\n     *\n     * @param      {String}    stream  The stream name\n     * @param      {Function}  cb      Callback to be execute when a message\n     * arrives. The callback will receive `action` and `stream` parameters.\n      * @example\n     * const webSocketBridge = new WebSocketBridge();\n     * webSocketBridge.connect();\n     * webSocketBridge.listen();\n     * webSocketBridge.demultiplex('mystream', function(action, stream) {\n     *   console.log(action, stream);\n     * });\n     * webSocketBridge.demultiplex('myotherstream', function(action, stream) {\n     *   console.info(action, stream);\n     * });\n     */\n\n  }, {\n    key: 'demultiplex',\n    value: function demultiplex(stream, cb) {\n      this.streams[stream] = cb;\n    }\n\n    /**\n     * Sends a message to the reply channel.\n     *\n     * @param      {Object}  msg     The message\n     *\n     * @example\n     * webSocketBridge.send({prop1: 'value1', prop2: 'value1'});\n     */\n\n  }, {\n    key: 'send',\n    value: function send(msg) {\n      this.socket.send(JSON.stringify(msg));\n    }\n\n    /**\n     * Returns an object to send messages to a specific stream\n     *\n     * @param      {String}  stream  The stream name\n     * @return     {Object}  convenience object to send messages to `stream`.\n     * @example\n     * webSocketBridge.stream('mystream').send({prop1: 'value1', prop2: 'value1'})\n     */\n\n  }, {\n    key: 'stream',\n    value: function stream(_stream) {\n      var _this2 = this;\n\n      return {\n        send: function send(action) {\n          var msg = {\n            stream: _stream,\n            payload: action\n          };\n          _this2.socket.send(JSON.stringify(msg));\n        }\n      };\n    }\n  }]);\n\n  return WebSocketBridge;\n}();\n\nexports.WebSocketBridge = WebSocketBridge;\n\n/***/ }),\n/* 1 */\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n\"use strict\";\nObject.defineProperty(__webpack_exports__, \"__esModule\", { value: true });\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_django_channels__ = __webpack_require__(0);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_django_channels___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0_django_channels__);\n// based on [vue-websocket](https://github.com/icebob/vue-websocket)\n\n\n\n/* harmony default export */ __webpack_exports__[\"default\"] = ({\n    install: function install(Vue, url, protocols, options) {\n\n        var webSocketBridge = new __WEBPACK_IMPORTED_MODULE_0_django_channels__[\"WebSocketBridge\"]();\n\n        webSocketBridge.connect(url, protocols, options);\n        webSocketBridge.listen();\n\n        Vue.prototype.$channels = webSocketBridge;\n        Vue.prototype.$socket = webSocketBridge.socket;\n\n        var addListeners = function addListeners() {\n            var _this = this;\n\n            if (this.$options[\"channels\"]) {\n                var conf = this.$options.channels;\n\n                if (conf.events) {\n                    var prefix = conf.prefix || \"\";\n                    Object.keys(conf.events).forEach(function (key) {\n                        var func = conf.events[key].bind(_this);\n                        _this.$socket.addEventListener(prefix + key, func);\n                        conf.events[key].__binded = func;\n                    });\n                }\n            }\n        };\n\n        var removeListeners = function removeListeners() {\n            var _this2 = this;\n\n            if (this.$options[\"channels\"]) {\n                var conf = this.$options.channels;\n\n                if (conf.events) {\n                    var prefix = conf.prefix || \"\";\n                    Object.keys(conf.events).forEach(function (key) {\n                        _this2.$socket.removeEventListener(prefix + key, conf.events[key].__binded);\n                    });\n                }\n            }\n        };\n\n        var addStreamHandlers = function addStreamHandlers() {\n            var _this3 = this;\n\n            if (this.$options[\"channels\"]) {\n                var conf = this.$options.channels;\n\n                if (conf.streams) {\n                    Object.keys(conf.streams).forEach(function (stream) {\n                        var func = conf.streams[stream].bind(_this3);\n                        _this3.$channels.demultiplex(stream, func);\n                    });\n                }\n            }\n        };\n\n        Vue.mixin({\n            // Vue v1.x\n            beforeCompile: addListeners,\n            // Vue v2.x\n            beforeCreate: addListeners,\n\n            created: addStreamHandlers,\n\n            beforeDestroy: removeListeners\n        });\n    }\n});\n\n/***/ }),\n/* 2 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\nvar isWebSocket = function (constructor) {\n    return constructor && constructor.CLOSING === 2;\n};\nvar isGlobalWebSocket = function () {\n    return typeof WebSocket !== 'undefined' && isWebSocket(WebSocket);\n};\nvar getDefaultOptions = function () { return ({\n    constructor: isGlobalWebSocket() ? WebSocket : null,\n    maxReconnectionDelay: 10000,\n    minReconnectionDelay: 1500,\n    reconnectionDelayGrowFactor: 1.3,\n    connectionTimeout: 4000,\n    maxRetries: Infinity,\n    debug: false,\n}); };\nvar bypassProperty = function (src, dst, name) {\n    Object.defineProperty(dst, name, {\n        get: function () { return src[name]; },\n        set: function (value) { src[name] = value; },\n        enumerable: true,\n        configurable: true,\n    });\n};\nvar initReconnectionDelay = function (config) {\n    return (config.minReconnectionDelay + Math.random() * config.minReconnectionDelay);\n};\nvar updateReconnectionDelay = function (config, previousDelay) {\n    var newDelay = previousDelay * config.reconnectionDelayGrowFactor;\n    return (newDelay > config.maxReconnectionDelay)\n        ? config.maxReconnectionDelay\n        : newDelay;\n};\nvar LEVEL_0_EVENTS = ['onopen', 'onclose', 'onmessage', 'onerror'];\nvar reassignEventListeners = function (ws, oldWs, listeners) {\n    Object.keys(listeners).forEach(function (type) {\n        listeners[type].forEach(function (_a) {\n            var listener = _a[0], options = _a[1];\n            ws.addEventListener(type, listener, options);\n        });\n    });\n    if (oldWs) {\n        LEVEL_0_EVENTS.forEach(function (name) { ws[name] = oldWs[name]; });\n    }\n};\nvar ReconnectingWebsocket = function (url, protocols, options) {\n    var _this = this;\n    if (options === void 0) { options = {}; }\n    var ws;\n    var connectingTimeout;\n    var reconnectDelay = 0;\n    var retriesCount = 0;\n    var shouldRetry = true;\n    var savedOnClose = null;\n    var listeners = {};\n    // require new to construct\n    if (!(this instanceof ReconnectingWebsocket)) {\n        throw new TypeError(\"Failed to construct 'ReconnectingWebSocket': Please use the 'new' operator\");\n    }\n    // Set config. Not using `Object.assign` because of IE11\n    var config = getDefaultOptions();\n    Object.keys(config)\n        .filter(function (key) { return options.hasOwnProperty(key); })\n        .forEach(function (key) { return config[key] = options[key]; });\n    if (!isWebSocket(config.constructor)) {\n        throw new TypeError('Invalid WebSocket constructor. Set `options.constructor`');\n    }\n    var log = config.debug ? function () {\n        var params = [];\n        for (var _i = 0; _i < arguments.length; _i++) {\n            params[_i - 0] = arguments[_i];\n        }\n        return console.log.apply(console, ['RWS:'].concat(params));\n    } : function () { };\n    /**\n     * Not using dispatchEvent, otherwise we must use a DOM Event object\n     * Deferred because we want to handle the close event before this\n     */\n    var emitError = function (code, msg) { return setTimeout(function () {\n        var err = new Error(msg);\n        err.code = code;\n        if (Array.isArray(listeners.error)) {\n            listeners.error.forEach(function (_a) {\n                var fn = _a[0];\n                return fn(err);\n            });\n        }\n        if (ws.onerror) {\n            ws.onerror(err);\n        }\n    }, 0); };\n    var handleClose = function () {\n        log('close');\n        retriesCount++;\n        log('retries count:', retriesCount);\n        if (retriesCount > config.maxRetries) {\n            emitError('EHOSTDOWN', 'Too many failed connection attempts');\n            return;\n        }\n        if (!reconnectDelay) {\n            reconnectDelay = initReconnectionDelay(config);\n        }\n        else {\n            reconnectDelay = updateReconnectionDelay(config, reconnectDelay);\n        }\n        log('reconnectDelay:', reconnectDelay);\n        if (shouldRetry) {\n            setTimeout(connect, reconnectDelay);\n        }\n    };\n    var connect = function () {\n        log('connect');\n        var oldWs = ws;\n        ws = new config.constructor(url, protocols);\n        connectingTimeout = setTimeout(function () {\n            log('timeout');\n            ws.close();\n            emitError('ETIMEDOUT', 'Connection timeout');\n        }, config.connectionTimeout);\n        log('bypass properties');\n        for (var key in ws) {\n            // @todo move to constant\n            if (['addEventListener', 'removeEventListener', 'close', 'send'].indexOf(key) < 0) {\n                bypassProperty(ws, _this, key);\n            }\n        }\n        ws.addEventListener('open', function () {\n            clearTimeout(connectingTimeout);\n            log('open');\n            reconnectDelay = initReconnectionDelay(config);\n            log('reconnectDelay:', reconnectDelay);\n            retriesCount = 0;\n        });\n        ws.addEventListener('close', handleClose);\n        reassignEventListeners(ws, oldWs, listeners);\n        // because when closing with fastClose=true, it is saved and set to null to avoid double calls\n        ws.onclose = ws.onclose || savedOnClose;\n        savedOnClose = null;\n    };\n    log('init');\n    connect();\n    this.close = function (code, reason, _a) {\n        if (code === void 0) { code = 1000; }\n        if (reason === void 0) { reason = ''; }\n        var _b = _a === void 0 ? {} : _a, _c = _b.keepClosed, keepClosed = _c === void 0 ? false : _c, _d = _b.fastClose, fastClose = _d === void 0 ? true : _d, _e = _b.delay, delay = _e === void 0 ? 0 : _e;\n        if (delay) {\n            reconnectDelay = delay;\n        }\n        shouldRetry = !keepClosed;\n        ws.close(code, reason);\n        if (fastClose) {\n            var fakeCloseEvent_1 = {\n                code: code,\n                reason: reason,\n                wasClean: true,\n            };\n            // execute close listeners soon with a fake closeEvent\n            // and remove them from the WS instance so they\n            // don't get fired on the real close.\n            handleClose();\n            ws.removeEventListener('close', handleClose);\n            // run and remove level2\n            if (Array.isArray(listeners.close)) {\n                listeners.close.forEach(function (_a) {\n                    var listener = _a[0], options = _a[1];\n                    listener(fakeCloseEvent_1);\n                    ws.removeEventListener('close', listener, options);\n                });\n            }\n            // run and remove level0\n            if (ws.onclose) {\n                savedOnClose = ws.onclose;\n                ws.onclose(fakeCloseEvent_1);\n                ws.onclose = null;\n            }\n        }\n    };\n    this.send = function (data) {\n        ws.send(data);\n    };\n    this.addEventListener = function (type, listener, options) {\n        if (Array.isArray(listeners[type])) {\n            if (!listeners[type].some(function (_a) {\n                var l = _a[0];\n                return l === listener;\n            })) {\n                listeners[type].push([listener, options]);\n            }\n        }\n        else {\n            listeners[type] = [[listener, options]];\n        }\n        ws.addEventListener(type, listener, options);\n    };\n    this.removeEventListener = function (type, listener, options) {\n        if (Array.isArray(listeners[type])) {\n            listeners[type] = listeners[type].filter(function (_a) {\n                var l = _a[0];\n                return l !== listener;\n            });\n        }\n        ws.removeEventListener(type, listener, options);\n    };\n};\nmodule.exports = ReconnectingWebsocket;\n\n\n/***/ })\n/******/ ]);\n\n\n// WEBPACK FOOTER //\n// vue-django-channels.js"," \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId])\n \t\t\treturn installedModules[moduleId].exports;\n\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// identity function for calling harmony imports with the correct context\n \t__webpack_require__.i = function(value) { return value; };\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, {\n \t\t\t\tconfigurable: false,\n \t\t\t\tenumerable: true,\n \t\t\t\tget: getter\n \t\t\t});\n \t\t}\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"/dist/\";\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = 1);\n\n\n\n// WEBPACK FOOTER //\n// webpack/bootstrap 1597307d271c0bece0d9","'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.WebSocketBridge = undefined;\n\nvar _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nvar _reconnectingWebsocket = require('reconnecting-websocket');\n\nvar _reconnectingWebsocket2 = _interopRequireDefault(_reconnectingWebsocket);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\n/**\n * Bridge between Channels and plain javascript.\n *\n * @example\n * const webSocketBridge = new WebSocketBridge();\n * webSocketBridge.connect();\n * webSocketBridge.listen(function(action, stream) {\n *   console.log(action, stream);\n * });\n */\nvar WebSocketBridge = function () {\n  function WebSocketBridge(options) {\n    _classCallCheck(this, WebSocketBridge);\n\n    /**\n     * The underlaying `ReconnectingWebSocket` instance.\n     * \n     * @type {ReconnectingWebSocket}\n     */\n    this.socket = null;\n    this.streams = {};\n    this.default_cb = null;\n    this.options = _extends({}, options);\n  }\n\n  /**\n   * Connect to the websocket server\n   *\n   * @param      {String}  [url]     The url of the websocket. Defaults to\n   * `window.location.host`\n   * @param      {String[]|String}  [protocols] Optional string or array of protocols.\n   * @param      {Object} options Object of options for [`reconnecting-websocket`](https://github.com/joewalnes/reconnecting-websocket#options-1).\n   * @example\n   * const webSocketBridge = new WebSocketBridge();\n   * webSocketBridge.connect();\n   */\n\n\n  _createClass(WebSocketBridge, [{\n    key: 'connect',\n    value: function connect(url, protocols, options) {\n      var _url = void 0;\n      // Use wss:// if running on https://\n      var scheme = window.location.protocol === 'https:' ? 'wss' : 'ws';\n      var base_url = scheme + '://' + window.location.host;\n      if (url === undefined) {\n        _url = base_url;\n      } else {\n        // Support relative URLs\n        if (url[0] == '/') {\n          _url = '' + base_url + url;\n        } else {\n          _url = url;\n        }\n      }\n      this.socket = new _reconnectingWebsocket2.default(_url, protocols, options);\n    }\n\n    /**\n     * Starts listening for messages on the websocket, demultiplexing if necessary.\n     *\n     * @param      {Function}  [cb]         Callback to be execute when a message\n     * arrives. The callback will receive `action` and `stream` parameters\n     *\n     * @example\n     * const webSocketBridge = new WebSocketBridge();\n     * webSocketBridge.connect();\n     * webSocketBridge.listen(function(action, stream) {\n     *   console.log(action, stream);\n     * });\n     */\n\n  }, {\n    key: 'listen',\n    value: function listen(cb) {\n      var _this = this;\n\n      this.default_cb = cb;\n      this.socket.onmessage = function (event) {\n        var msg = JSON.parse(event.data);\n        var action = void 0;\n        var stream = void 0;\n\n        if (msg.stream !== undefined) {\n          action = msg.payload;\n          stream = msg.stream;\n          var stream_cb = _this.streams[stream];\n          stream_cb ? stream_cb(action, stream) : null;\n        } else {\n          action = msg;\n          stream = null;\n          _this.default_cb ? _this.default_cb(action, stream) : null;\n        }\n      };\n    }\n\n    /**\n     * Adds a 'stream handler' callback. Messages coming from the specified stream\n     * will call the specified callback.\n     *\n     * @param      {String}    stream  The stream name\n     * @param      {Function}  cb      Callback to be execute when a message\n     * arrives. The callback will receive `action` and `stream` parameters.\n      * @example\n     * const webSocketBridge = new WebSocketBridge();\n     * webSocketBridge.connect();\n     * webSocketBridge.listen();\n     * webSocketBridge.demultiplex('mystream', function(action, stream) {\n     *   console.log(action, stream);\n     * });\n     * webSocketBridge.demultiplex('myotherstream', function(action, stream) {\n     *   console.info(action, stream);\n     * });\n     */\n\n  }, {\n    key: 'demultiplex',\n    value: function demultiplex(stream, cb) {\n      this.streams[stream] = cb;\n    }\n\n    /**\n     * Sends a message to the reply channel.\n     *\n     * @param      {Object}  msg     The message\n     *\n     * @example\n     * webSocketBridge.send({prop1: 'value1', prop2: 'value1'});\n     */\n\n  }, {\n    key: 'send',\n    value: function send(msg) {\n      this.socket.send(JSON.stringify(msg));\n    }\n\n    /**\n     * Returns an object to send messages to a specific stream\n     *\n     * @param      {String}  stream  The stream name\n     * @return     {Object}  convenience object to send messages to `stream`.\n     * @example\n     * webSocketBridge.stream('mystream').send({prop1: 'value1', prop2: 'value1'})\n     */\n\n  }, {\n    key: 'stream',\n    value: function stream(_stream) {\n      var _this2 = this;\n\n      return {\n        send: function send(action) {\n          var msg = {\n            stream: _stream,\n            payload: action\n          };\n          _this2.socket.send(JSON.stringify(msg));\n        }\n      };\n    }\n  }]);\n\n  return WebSocketBridge;\n}();\n\nexports.WebSocketBridge = WebSocketBridge;\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/django-channels/lib/index.js\n// module id = 0\n// module chunks = 0","// based on [vue-websocket](https://github.com/icebob/vue-websocket)\r\n\r\nimport { WebSocketBridge } from 'django-channels';\r\n\r\nexport default {\r\n\r\n    install(Vue, url, protocols, options) {\r\n\r\n        let webSocketBridge = new WebSocketBridge()\r\n\r\n        webSocketBridge.connect(url, protocols, options);\r\n        webSocketBridge.listen();\r\n\r\n        Vue.prototype.$channels = webSocketBridge;\r\n        Vue.prototype.$socket = webSocketBridge.socket;\r\n\r\n        let addListeners = function () {\r\n            if (this.$options[\"channels\"]) {\r\n                let conf = this.$options.channels;\r\n\r\n                if (conf.events) {\r\n                    let prefix = conf.prefix || \"\";\r\n                    Object.keys(conf.events).forEach((key) => {\r\n                        let func = conf.events[key].bind(this);\r\n                        this.$socket.addEventListener(prefix + key, func);\r\n                        conf.events[key].__binded = func;\r\n                    });\r\n                }\r\n            }\r\n        };\r\n\r\n        let removeListeners = function () {\r\n            if (this.$options[\"channels\"]) {\r\n                let conf = this.$options.channels;\r\n\r\n                if (conf.events) {\r\n                    let prefix = conf.prefix || \"\";\r\n                    Object.keys(conf.events).forEach((key) => {\r\n                        this.$socket.removeEventListener(prefix + key, conf.events[key].__binded);\r\n                    });\r\n                }\r\n            }\r\n        };\r\n\r\n        let addStreamHandlers = function () {\r\n            if (this.$options[\"channels\"]) {\r\n                let conf = this.$options.channels;\r\n\r\n                if (conf.streams) {\r\n                    Object.keys(conf.streams).forEach((stream) => {\r\n                        let func = conf.streams[stream].bind(this);\r\n                        this.$channels.demultiplex(stream, func);\r\n                    });\r\n                }\r\n            }\r\n        };\r\n\r\n        Vue.mixin({\r\n            // Vue v1.x\r\n            beforeCompile: addListeners,\r\n            // Vue v2.x\r\n            beforeCreate: addListeners,\r\n\r\n            created: addStreamHandlers,\r\n\r\n            beforeDestroy: removeListeners\r\n        });\r\n    }\r\n};\r\n\n\n\n// WEBPACK FOOTER //\n// ./src/index.js","\"use strict\";\nvar isWebSocket = function (constructor) {\n    return constructor && constructor.CLOSING === 2;\n};\nvar isGlobalWebSocket = function () {\n    return typeof WebSocket !== 'undefined' && isWebSocket(WebSocket);\n};\nvar getDefaultOptions = function () { return ({\n    constructor: isGlobalWebSocket() ? WebSocket : null,\n    maxReconnectionDelay: 10000,\n    minReconnectionDelay: 1500,\n    reconnectionDelayGrowFactor: 1.3,\n    connectionTimeout: 4000,\n    maxRetries: Infinity,\n    debug: false,\n}); };\nvar bypassProperty = function (src, dst, name) {\n    Object.defineProperty(dst, name, {\n        get: function () { return src[name]; },\n        set: function (value) { src[name] = value; },\n        enumerable: true,\n        configurable: true,\n    });\n};\nvar initReconnectionDelay = function (config) {\n    return (config.minReconnectionDelay + Math.random() * config.minReconnectionDelay);\n};\nvar updateReconnectionDelay = function (config, previousDelay) {\n    var newDelay = previousDelay * config.reconnectionDelayGrowFactor;\n    return (newDelay > config.maxReconnectionDelay)\n        ? config.maxReconnectionDelay\n        : newDelay;\n};\nvar LEVEL_0_EVENTS = ['onopen', 'onclose', 'onmessage', 'onerror'];\nvar reassignEventListeners = function (ws, oldWs, listeners) {\n    Object.keys(listeners).forEach(function (type) {\n        listeners[type].forEach(function (_a) {\n            var listener = _a[0], options = _a[1];\n            ws.addEventListener(type, listener, options);\n        });\n    });\n    if (oldWs) {\n        LEVEL_0_EVENTS.forEach(function (name) { ws[name] = oldWs[name]; });\n    }\n};\nvar ReconnectingWebsocket = function (url, protocols, options) {\n    var _this = this;\n    if (options === void 0) { options = {}; }\n    var ws;\n    var connectingTimeout;\n    var reconnectDelay = 0;\n    var retriesCount = 0;\n    var shouldRetry = true;\n    var savedOnClose = null;\n    var listeners = {};\n    // require new to construct\n    if (!(this instanceof ReconnectingWebsocket)) {\n        throw new TypeError(\"Failed to construct 'ReconnectingWebSocket': Please use the 'new' operator\");\n    }\n    // Set config. Not using `Object.assign` because of IE11\n    var config = getDefaultOptions();\n    Object.keys(config)\n        .filter(function (key) { return options.hasOwnProperty(key); })\n        .forEach(function (key) { return config[key] = options[key]; });\n    if (!isWebSocket(config.constructor)) {\n        throw new TypeError('Invalid WebSocket constructor. Set `options.constructor`');\n    }\n    var log = config.debug ? function () {\n        var params = [];\n        for (var _i = 0; _i < arguments.length; _i++) {\n            params[_i - 0] = arguments[_i];\n        }\n        return console.log.apply(console, ['RWS:'].concat(params));\n    } : function () { };\n    /**\n     * Not using dispatchEvent, otherwise we must use a DOM Event object\n     * Deferred because we want to handle the close event before this\n     */\n    var emitError = function (code, msg) { return setTimeout(function () {\n        var err = new Error(msg);\n        err.code = code;\n        if (Array.isArray(listeners.error)) {\n            listeners.error.forEach(function (_a) {\n                var fn = _a[0];\n                return fn(err);\n            });\n        }\n        if (ws.onerror) {\n            ws.onerror(err);\n        }\n    }, 0); };\n    var handleClose = function () {\n        log('close');\n        retriesCount++;\n        log('retries count:', retriesCount);\n        if (retriesCount > config.maxRetries) {\n            emitError('EHOSTDOWN', 'Too many failed connection attempts');\n            return;\n        }\n        if (!reconnectDelay) {\n            reconnectDelay = initReconnectionDelay(config);\n        }\n        else {\n            reconnectDelay = updateReconnectionDelay(config, reconnectDelay);\n        }\n        log('reconnectDelay:', reconnectDelay);\n        if (shouldRetry) {\n            setTimeout(connect, reconnectDelay);\n        }\n    };\n    var connect = function () {\n        log('connect');\n        var oldWs = ws;\n        ws = new config.constructor(url, protocols);\n        connectingTimeout = setTimeout(function () {\n            log('timeout');\n            ws.close();\n            emitError('ETIMEDOUT', 'Connection timeout');\n        }, config.connectionTimeout);\n        log('bypass properties');\n        for (var key in ws) {\n            // @todo move to constant\n            if (['addEventListener', 'removeEventListener', 'close', 'send'].indexOf(key) < 0) {\n                bypassProperty(ws, _this, key);\n            }\n        }\n        ws.addEventListener('open', function () {\n            clearTimeout(connectingTimeout);\n            log('open');\n            reconnectDelay = initReconnectionDelay(config);\n            log('reconnectDelay:', reconnectDelay);\n            retriesCount = 0;\n        });\n        ws.addEventListener('close', handleClose);\n        reassignEventListeners(ws, oldWs, listeners);\n        // because when closing with fastClose=true, it is saved and set to null to avoid double calls\n        ws.onclose = ws.onclose || savedOnClose;\n        savedOnClose = null;\n    };\n    log('init');\n    connect();\n    this.close = function (code, reason, _a) {\n        if (code === void 0) { code = 1000; }\n        if (reason === void 0) { reason = ''; }\n        var _b = _a === void 0 ? {} : _a, _c = _b.keepClosed, keepClosed = _c === void 0 ? false : _c, _d = _b.fastClose, fastClose = _d === void 0 ? true : _d, _e = _b.delay, delay = _e === void 0 ? 0 : _e;\n        if (delay) {\n            reconnectDelay = delay;\n        }\n        shouldRetry = !keepClosed;\n        ws.close(code, reason);\n        if (fastClose) {\n            var fakeCloseEvent_1 = {\n                code: code,\n                reason: reason,\n                wasClean: true,\n            };\n            // execute close listeners soon with a fake closeEvent\n            // and remove them from the WS instance so they\n            // don't get fired on the real close.\n            handleClose();\n            ws.removeEventListener('close', handleClose);\n            // run and remove level2\n            if (Array.isArray(listeners.close)) {\n                listeners.close.forEach(function (_a) {\n                    var listener = _a[0], options = _a[1];\n                    listener(fakeCloseEvent_1);\n                    ws.removeEventListener('close', listener, options);\n                });\n            }\n            // run and remove level0\n            if (ws.onclose) {\n                savedOnClose = ws.onclose;\n                ws.onclose(fakeCloseEvent_1);\n                ws.onclose = null;\n            }\n        }\n    };\n    this.send = function (data) {\n        ws.send(data);\n    };\n    this.addEventListener = function (type, listener, options) {\n        if (Array.isArray(listeners[type])) {\n            if (!listeners[type].some(function (_a) {\n                var l = _a[0];\n                return l === listener;\n            })) {\n                listeners[type].push([listener, options]);\n            }\n        }\n        else {\n            listeners[type] = [[listener, options]];\n        }\n        ws.addEventListener(type, listener, options);\n    };\n    this.removeEventListener = function (type, listener, options) {\n        if (Array.isArray(listeners[type])) {\n            listeners[type] = listeners[type].filter(function (_a) {\n                var l = _a[0];\n                return l !== listener;\n            });\n        }\n        ws.removeEventListener(type, listener, options);\n    };\n};\nmodule.exports = ReconnectingWebsocket;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/reconnecting-websocket/dist/index.js\n// module id = 2\n// module chunks = 0"],"sourceRoot":""}